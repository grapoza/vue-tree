import { expect, describe, it, beforeEach, afterEach, vi } from 'vitest';
import { flushPromises, shallowMount } from '@vue/test-utils';
import TreeView from '../../src/components/TreeView.vue';
import { generateNodes } from '../data/node-generator.js';
import SelectionMode from '../../src/enums/selectionMode';

async function createWrapper(customPropsData, customAttrs, slotsData) {
  let wrapper = shallowMount(TreeView, {
    sync: false,
    props: customPropsData || {},
    attrs: customAttrs,
    slots: slotsData
  });

  await flushPromises();

  return wrapper;
}

describe('TreeView.vue', () => {

  let wrapper = null;

  afterEach(() => {
    wrapper = null;
  });

  describe('when on an element with an ID', () => {

    beforeEach(async () => {
      wrapper = await createWrapper(null, { id: 'my-id' });
    });

    it('should have a uniqueId of the root element ID', () => {
      expect(wrapper.vm.uniqueId).to.equal(wrapper.attributes('id'));
    });
  });

  describe('when on an element without an ID', () => {

    beforeEach(async () => {
      wrapper = await createWrapper();
    });

    it('should have an autogenerated uniqueId prefixed with grt-', () => {
      expect(wrapper.vm.uniqueId).to.be.a('string').and.match(/^grt-/i);
    });
  });

  describe('when not passed a skinClass prop', () => {

    beforeEach(async () => {
      wrapper = await createWrapper();
    });

    it('should have a class of grtv-default-skin', () => {
      expect(wrapper.vm.skinClass).to.equal('grtv-default-skin');
      let target = wrapper.find('.grtv-wrapper.grtv-default-skin');
      expect(target.exists()).to.be.true;
    });
  });

  describe('when passed a skinClass prop', () => {

    beforeEach(async () => {
      wrapper = await createWrapper({ skinClass: "my-skin" });
    });

    it('should have a class of my-skin', () => {
      expect(wrapper.vm.skinClass).to.equal('my-skin');
      let target = wrapper.find('.grtv-wrapper.my-skin');
      expect(target.exists()).to.be.true;
    });

    it('should not have a class of grtv-default-skin', () => {
      let target = wrapper.find('.grtv-wrapper.grtv-default-skin');
      expect(target.exists()).to.be.false;
    });
  });

  describe('when getCheckedCheckboxes() is called', () => {

    beforeEach(async () => {
      wrapper = await createWrapper({ initialModel: generateNodes(['ecs', 'eCs', ['eCs', 'ecs']]) });
    });

    it('should return checked checkbox nodes', () => {
      let nodes = wrapper.vm.getCheckedCheckboxes();
      expect(nodes.length).to.equal(2);
    });
  });

  describe('when getCheckedRadioButtons() is called', () => {

    beforeEach(async () => {
      let nodes = generateNodes(['ers', 'eRs', ['eRs', 'ers']]);
      wrapper = await createWrapper({ initialModel: nodes });

      // Fake the setup of the radio storage since we're shallow mounting
      wrapper.vm.radioGroupValues = {};
      wrapper.vm.radioGroupValues[nodes[1].treeNodeSpec.input.name] = nodes[1].treeNodeSpec.input.value;
      wrapper.vm.radioGroupValues[nodes[1].children[0].treeNodeSpec.input.name] = nodes[1].children[0].treeNodeSpec.input.value;
    });

    it('should return checked radiobutton nodes', () => {
      let nodes = wrapper.vm.getCheckedRadioButtons();
      expect(nodes.length).to.equal(2);
    });
  });

  describe('when getMatching() is called', () => {

    describe('and there are nodes present', () => {

      beforeEach(async () => {
        wrapper = await createWrapper({ initialModel: generateNodes(['es', 'ES', ['es', 'eS']]), selectionMode: SelectionMode.Multiple });
      });

      it('should return nodes matched by the function argument', () => {
        let nodes = wrapper.vm.getMatching((nodeModel) =>
          nodeModel.treeNodeSpec.expandable
          && nodeModel.treeNodeSpec.state.expanded
          && nodeModel.treeNodeSpec.selectable
          && nodeModel.treeNodeSpec.state.selected);

        expect(nodes.length).to.equal(1);
      });
    });

    describe('and there are no nodes present', () => {

      beforeEach(async () => {
        wrapper = await createWrapper();
      });

      it('should return an empty array', () => {
        let nodes = wrapper.vm.getMatching(() => true);
        expect(nodes.length).to.equal(0);
      });
    });

    describe('and maxMatches argumetn is provided (> 0)', () => {

      beforeEach(async () => {
        wrapper = await createWrapper({ initialModel: generateNodes(['es', 'ES', ['es', 'eS']]), selectionMode: SelectionMode.Multiple });
      });

      it('should return up to maxMatches matches', () => {
        let nodes = wrapper.vm.getMatching(() => true, 2);
        expect(nodes.length).to.equal(2);
      });
    });
  });

  describe('when getSelected() is called', () => {

    beforeEach(async () => {
      wrapper = await createWrapper({ initialModel: generateNodes(['es', 'eS', ['es', 'eS']]), selectionMode: SelectionMode.Multiple });
    });

    it('should return selected nodes', () => {
      let nodes = wrapper.vm.getSelected();
      expect(nodes.length).to.equal(2);
    });
  });

  describe('when selectionMode is null', () => {

    beforeEach(async () => {
      wrapper = await createWrapper({ initialModel: generateNodes(['es', 'eS', ['es', 'eS']]), selectionMode: SelectionMode.None });
    });

    it('should not have an aria-multiselectable attribute', () => {
      expect(wrapper.find('.grtv').element.attributes['aria-multiselectable']).to.be.undefined;
    });

    it('should ignore the selected state of nodes', () => {
      let nodes = wrapper.vm.getSelected();
      expect(nodes.length).to.equal(0);
    });
  });

  describe('when selectionMode is `single`', () => {

    beforeEach(async () => {
      wrapper = await createWrapper({ initialModel: generateNodes(['es', 'eS', ['es', 'eS']]), selectionMode: SelectionMode.Single });
    });

    it('should have an aria-multiselectable attribute of false', () => {
      expect(wrapper.find('.grtv').element.attributes['aria-multiselectable'].value).to.equal('false');
    });

    it('should only keep the selectable=true state for the first node with that in the initial model', () => {
      expect(wrapper.vm.model[1].treeNodeSpec.state.selected).to.be.true;
      expect(wrapper.vm.model[1].children[1].treeNodeSpec.state.selected).to.be.false;
    });
  });

  describe('when selectionMode is `selectionFollowsFocus`', () => {

    beforeEach(async () => {
      wrapper = await createWrapper({ initialModel: generateNodes(['es', 'eS', ['es', 'eS']]), selectionMode: SelectionMode.SelectionFollowsFocus });
    });

    it('should have an aria-multiselectable attribute of false', () => {
      expect(wrapper.find('.grtv').element.attributes['aria-multiselectable'].value).to.equal('false');
    });
  });

  describe('when selectionMode is `multiple`', () => {

    beforeEach(async () => {
      wrapper = await createWrapper({ initialModel: generateNodes(['es', 'eS', ['es', 'eS']]), selectionMode: SelectionMode.Multiple });
    });

    it('should have an aria-multiselectable attribute of true', () => {
      expect(wrapper.find('.grtv').element.attributes['aria-multiselectable'].value).to.equal('true');
    });
  });

  describe('when a function is passed for loadNodesAsync', () => {

    let loadNodesPromise = null;

    beforeEach(async () => {
      vi.useFakeTimers();
      loadNodesPromise = new Promise(resolve => setTimeout(resolve.bind(null, generateNodes(['', ''])), 1000));
      wrapper = await createWrapper({ loadNodesAsync: () => loadNodesPromise, selectionMode: SelectionMode.Single });
    });

    afterEach(() => {
      vi.useRealTimers();
    });

    describe('and the loadNodesAsync Promise has not returned', () => {

      it('should display the loading placeholder', () => {
        expect(wrapper.find('.grtv-loading').exists()).to.be.true;
      });

      describe('and rendering a custom loader message', () => {

        beforeEach(async () => {
          wrapper = await createWrapper(
            {
              loadNodesAsync: () => loadNodesPromise
            },
            null,
            {
              'loading-root': '<span class="loading-slot-content">custom</span>',
            }
          );
        });

        it('should render the slot template', () => {
          expect(wrapper.find('.loading-slot-content').exists()).to.be.true;
        });
      });
    });

    describe('and the loadNodesAsync Promise returns', () => {

      beforeEach(async () => {
        vi.runAllTimers();
        await wrapper.vm.$nextTick();
      });

      it('should splice those nodes in as the model', () => {
        expect(wrapper.find('.grtv-loading').exists()).to.be.false;
        expect(wrapper.vm.model.length).to.equal(2);
      });

      it('should emit the treeRootNodesLoad event', () => {
        expect(wrapper.emitted().treeRootNodesLoad).to.be.an('array').that.has.length(1);
      });
    });
  });
});
